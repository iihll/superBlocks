<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>超级方块游戏</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <!-- 引入 Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center">
  <div id="container" class="flex flex-col items-center w-full max-w-md mx-auto">
    <h2 class="text-2xl font-bold mt-6 mb-2 text-blue-600">超级方块游戏</h2>
    <div id="status" class="mb-2 text-lg text-red-500"></div>
    <button id="restart" class="mb-4 px-6 py-2 bg-blue-500 text-white rounded shadow hover:bg-blue-600 transition">重新开始</button>
    <div class="rounded-xl shadow-lg bg-gray-200 p-2">
      <canvas id="game" width="360" height="360" class="rounded-xl bg-gray-300"></canvas>
    </div>
  </div>
  <script>
    const SIZE = 9, BLOCK_TYPES = 7;
    const COLORS = ["#e74c3c","#3498db","#f1c40f","#2ecc71","#9b59b6","#e67e22","#1abc9c"];
    let board = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
    let selected = null, gameOver = false;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let cellSize = canvas.width / SIZE;

    function resizeCanvas() {
      let w = Math.min(window.innerWidth * 0.9, 400);
      canvas.width = canvas.height = w;
      cellSize = w / SIZE;
      render();
    }
    window.addEventListener('resize', resizeCanvas);

    function randomEmptyCells(n) {
      let empties = [];
      for (let r = 0; r < SIZE; r++)
        for (let c = 0; c < SIZE; c++)
          if (!board[r][c]) empties.push([r, c]);
      return empties.sort(() => Math.random() - 0.5).slice(0, n);
    }

    function addRandomBlocks(n) {
      let cells = randomEmptyCells(n);
      cells.forEach(([r, c]) => {
        board[r][c] = Math.floor(Math.random() * BLOCK_TYPES);
      });
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          ctx.strokeStyle = "#ccc";
          ctx.lineWidth = 1;
          ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
          if (board[r][c] !== null) {
            ctx.beginPath();
            ctx.arc(
              c * cellSize + cellSize / 2,
              r * cellSize + cellSize / 2,
              cellSize * 0.38,
              0, 2 * Math.PI
            );
            ctx.fillStyle = COLORS[board[r][c]];
            ctx.fill();
            if (selected && selected[0] === r && selected[1] === c) {
              ctx.lineWidth = 4;
              ctx.strokeStyle = "#333";
              ctx.stroke();
            }
          }
        }
      }
      document.getElementById('status').textContent = gameOver ? '游戏结束！' : '';
    }

    function bfsPath(from, to) {
      let visited = Array.from({length: SIZE}, () => Array(SIZE).fill(false));
      let queue = [from];
      visited[from[0]][from[1]] = true;
      let dirs = [[0,1],[1,0],[0,-1],[-1,0]];
      while (queue.length) {
        let [r, c] = queue.shift();
        if (r === to[0] && c === to[1]) return true;
        for (let [dr, dc] of dirs) {
          let nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE &&
              !visited[nr][nc] && board[nr][nc] === null) {
            visited[nr][nc] = true;
            queue.push([nr, nc]);
          }
        }
      }
      return false;
    }

    function findPath(from, to) {
      // BFS 获取路径
      let visited = Array.from({length: SIZE}, () => Array(SIZE).fill(false));
      let prev = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
      let queue = [from];
      visited[from[0]][from[1]] = true;
      let dirs = [[0,1],[1,0],[0,-1],[-1,0]];
      while (queue.length) {
        let [r, c] = queue.shift();
        if (r === to[0] && c === to[1]) break;
        for (let [dr, dc] of dirs) {
          let nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE &&
              !visited[nr][nc] && board[nr][nc] === null) {
            visited[nr][nc] = true;
            prev[nr][nc] = [r, c];
            queue.push([nr, nc]);
          }
        }
      }
      // 回溯路径
      let path = [];
      let cur = to;
      while (cur && !(cur[0] === from[0] && cur[1] === from[1])) {
        path.push(cur);
        cur = prev[cur[0]][cur[1]];
      }
      path.push(from);
      path.reverse();
      return path;
    }

    function checkAndRemoveLines() {
      let removed = false;
      let toRemove = Array.from({length: SIZE}, () => Array(SIZE).fill(false));
      function markLine(line) {
        if (line.length >= 5) {
          line.forEach(([r, c]) => toRemove[r][c] = true);
          removed = true;
        }
      }
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          let t = board[r][c];
          if (t === null) continue;
          let h = [[r, c]];
          for (let k = 1; c + k < SIZE && board[r][c + k] === t; k++) h.push([r, c + k]);
          markLine(h);
          let v = [[r, c]];
          for (let k = 1; r + k < SIZE && board[r + k][c] === t; k++) v.push([r + k, c]);
          markLine(v);
          let d1 = [[r, c]];
          for (let k = 1; r + k < SIZE && c + k < SIZE && board[r + k][c + k] === t; k++) d1.push([r + k, c + k]);
          markLine(d1);
          let d2 = [[r, c]];
          for (let k = 1; r + k < SIZE && c - k >= 0 && board[r + k][c - k] === t; k++) d2.push([r + k, c - k]);
          markLine(d2);
        }
      }
      for (let r = 0; r < SIZE; r++)
        for (let c = 0; c < SIZE; c++)
          if (toRemove[r][c]) board[r][c] = null;
      return removed;
    }

    function canMoveOrEliminate() {
      for (let r = 0; r < SIZE; r++)
        for (let c = 0; c < SIZE; c++)
          if (board[r][c] !== null) {
            for (let rr = 0; rr < SIZE; rr++)
              for (let cc = 0; cc < SIZE; cc++)
                if (board[rr][cc] === null && bfsPath([r, c], [rr, cc])) return true;
          }
      return false;
    }

    function getCellFromXY(x, y) {
      const rect = canvas.getBoundingClientRect();
      let cx = x - rect.left;
      let cy = y - rect.top;
      let c = Math.floor(cx / cellSize);
      let r = Math.floor(cy / cellSize);
      if (r >= 0 && r < SIZE && c >= 0 && c < SIZE) return [r, c];
      return null;
    }

    let animating = false;
    let animation = null;

    function animateMove(from, to, type, callback) {
      animating = true;
      const duration = 200; // ms
      const startTime = performance.now();
      function drawFrame(now) {
        let t = Math.min((now - startTime) / duration, 1);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw board except moving block
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 1;
            ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
            if (board[r][c] !== null && !(r === from[0] && c === from[1])) {
              ctx.beginPath();
              ctx.arc(
                c * cellSize + cellSize / 2,
                r * cellSize + cellSize / 2,
                cellSize * 0.38,
                0, 2 * Math.PI
              );
              ctx.fillStyle = COLORS[board[r][c]];
              ctx.fill();
            }
          }
        }
        // Draw moving block
        let x = from[1] * cellSize + cellSize / 2 + (to[1] - from[1]) * cellSize * t;
        let y = from[0] * cellSize + cellSize / 2 + (to[0] - from[0]) * cellSize * t;
        ctx.beginPath();
        ctx.arc(x, y, cellSize * 0.38, 0, 2 * Math.PI);
        ctx.fillStyle = COLORS[type];
        ctx.fill();
        if (t < 1) {
          animation = requestAnimationFrame(drawFrame);
        } else {
          animating = false;
          animation = null;
          callback();
        }
      }
      animation = requestAnimationFrame(drawFrame);
    }

    function animateMovePath(path, type, callback) {
      animating = true;
      const speed = 6; // 每帧移动的像素数，越大越快
      let totalSteps = 0;
      // 计算路径每段的像素距离
      for (let i = 1; i < path.length; i++) {
        totalSteps += Math.abs(path[i][0] - path[i-1][0]) + Math.abs(path[i][1] - path[i-1][1]);
      }
      let current = 0;
      let segment = 0;
      let progress = 0;

      function drawFrame() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw board except moving block
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 1;
            ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
            // 不画正在移动的格子
            if (board[r][c] !== null && !(r === path[segment][0] && c === path[segment][1])) {
              ctx.beginPath();
              ctx.arc(
                c * cellSize + cellSize / 2,
                r * cellSize + cellSize / 2,
                cellSize * 0.38,
                0, 2 * Math.PI
              );
              ctx.fillStyle = COLORS[board[r][c]];
              ctx.fill();
            }
          }
        }
        // 计算当前段的起止
        let [r1, c1] = path[segment];
        let [r2, c2] = path[segment + 1] || path[segment];
        let dx = c2 - c1, dy = r2 - r1;
        let dist = Math.abs(dx) + Math.abs(dy);
        if (dist === 0) dist = 1;
        let t = progress / (cellSize * dist);
        if (t > 1) t = 1;
        // 插值位置
        let x = (c1 + dx * t) * cellSize + cellSize / 2;
        let y = (r1 + dy * t) * cellSize + cellSize / 2;
        ctx.beginPath();
        ctx.arc(x, y, cellSize * 0.38, 0, 2 * Math.PI);
        ctx.fillStyle = COLORS[type];
        ctx.fill();

        progress += speed;
        if (progress >= cellSize * dist) {
          progress = 0;
          segment++;
        }
        if (segment < path.length - 1) {
          requestAnimationFrame(drawFrame);
        } else {
          animating = false;
          callback();
        }
      }
      drawFrame();
    }

    function onCanvasClick(e) {
      if (gameOver || animating) return;
      let pos;
      if (e.touches) {
        pos = getCellFromXY(e.touches[0].clientX, e.touches[0].clientY);
      } else {
        pos = getCellFromXY(e.clientX, e.clientY);
      }
      if (!pos) return;
      const [r, c] = pos;
      if (board[r][c] !== null) {
        selected = [r, c];
        render();
      } else if (selected) {
        if (bfsPath(selected, [r, c])) {
          // 动画移动，按路径逐步移动
          let from = [selected[0], selected[1]];
          let to = [r, c];
          let type = board[from[0]][from[1]];
          let path = findPath(from, to);
          board[from[0]][from[1]] = null;
          animateMovePath(path, type, () => {
            board[to[0]][to[1]] = type;
            selected = null;
            if (checkAndRemoveLines()) {
              // 消除后不生成新方块
            } else {
              addRandomBlocks(2);
              checkAndRemoveLines();
            }
            if (!canMoveOrEliminate()) {
              gameOver = true;
            }
            render();
          });
        }
      }
    }

    function restart() {
      board = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
      selected = null;
      gameOver = false;
      addRandomBlocks(5);
      render();
    }

    canvas.addEventListener('click', onCanvasClick);
    canvas.addEventListener('touchstart', function(e) {
      onCanvasClick(e);
      e.preventDefault();
    }, {passive: false});
    document.getElementById('restart').onclick = restart;

    resizeCanvas();
    restart();
  </script>
</body>
</html>